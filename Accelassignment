package org.usfirst.frc.team467.robot;
import org.apache.log4j.Logger;

import com.ctre.CANTalon;
import com.ctre.CANTalon.FeedbackDevice;
import com.ctre.CANTalon.TalonControlMode;

import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.Joystick.AxisType;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
public class Drive_Thing extends IterativeRobot {
	private static final Logger LOGGER = Logger.getLogger(Robot.class);

	final String defaultAuto = "Default";
	final String customAuto = "My Auto";
	String autoSelected;
	SendableChooser chooser;

	final int flID = 4;
	final int frID = 5;
	final int blID = 3;
	final int brID = 6;
	double Xaxis;
	double Yaxis;
 
	CANTalon fl;
	CANTalon fr;
	CANTalon bl;
	CANTalon br;

	Joystick stick;
	XboxController controller;
	private int trollId = 1;
	private boolean isScaled = true;
	private boolean diScaled = false;
	private double speedScaler = 1.0;
	private double turnScaler = 1.0;
	private double initialSpeedScaler = 1.0;
	private double initialTurnScaler = 1.0;

	/**
	 * This function is run when the robot is first started up and should be used
	 * for any initialization code.
	 */
	public void robotInit() {
		Logging.init();
		speedScaler = Double.parseDouble(SmartDashboard.getString("DB/String 0", "0.5"));
		turnScaler = Double.parseDouble(SmartDashboard.getString("DB/String 1", "0.5"));
		initialSpeedScaler = speedScaler;
		initialTurnScaler = turnScaler;
		chooser = new SendableChooser();
		chooser.addDefault("Default Auto", defaultAuto);
		chooser.addObject("My Auto", customAuto);
		SmartDashboard.putData("Auto choices", chooser);
		controller = new XboxController(0);
		stick = new Joystick(0);
		fl = new CANTalon(flID);
		fr = new CANTalon(frID);
		bl = new CANTalon(blID);
		br = new CANTalon(brID);
		
		
		fl.changeControlMode(TalonControlMode.PercentVbus);
		fl.setFeedbackDevice(FeedbackDevice.CtreMagEncoder_Relative);
		fl.reverseSensor(false);
		fl.configNominalOutputVoltage(+0.0f, -0.0f);
		fl.configPeakOutputVoltage(+12.0f, -12.0f);
		fl.setProfile(0);
		fl.setF(0);
		fl.setP(0);
		fl.setI(0);
		fl.setD(0);
		fl.setMotionMagicCruiseVelocity(0);
		fl.setMotionMagicAcceleration(0);

		bl.changeControlMode(TalonControlMode.Follower);

		fr.changeControlMode(TalonControlMode.PercentVbus);
		fr.setFeedbackDevice(FeedbackDevice.CtreMagEncoder_Relative);
		fr.reverseSensor(false);
		fr.configNominalOutputVoltage(+0.0f, -0.0f);
		fr.configPeakOutputVoltage(+12.0f, -12.0f);
		fr.setProfile(0);
		fr.setF(0);
		fr.setP(0);
		fr.setI(0);
		fr.setD(0);
		fr.setMotionMagicCruiseVelocity(0);
		fr.setMotionMagicAcceleration(0);

		br.changeControlMode(TalonControlMode.Follower);

		System.out.println(stick);
	}

	/**
	 * This autonomous (along with the chooser code above) shows how to select
	 * between different autonomous modes using the dashboard. The sendable chooser
	 * code works with the Java SmartDashboard. If you prefer the LabVIEW Dashboard,
	 * remove all of the chooser code and uncomment the getString line to get the
	 * auto name from the text box below the Gyro
	 *
	 * You can add additional auto modes by adding additional comparisons to the
	 * switch structure below with additional strings. If using the SendableChooser
	 * make sure to add them to the chooser code above as well.
	 */
	public void autonomousInit() {
//		autoSelected = (String) chooser.getSelected();
		// autoSelected = SmartDashboard.getString("Auto Selector", defaultAuto);
		System.out.println("Auto selected: " + autoSelected);
	}

	/**
	 * This function is called periodically during autonomous
	 */
	public void autonomousPeriodic() {
		switch (autoSelected) {
		case customAuto:
			// Put custom auto code here
			break;
		case defaultAuto:
		default:
			// Put default auto code here
			break;
		}
	}

	/**
	 * This function is called periodically during operator control
	 */
	public void teleopPeriodic() {
		if (isOperatorControl() && isEnabled() && stick.getRawButton(1)) {
			fl.changeControlMode(TalonControlMode.PercentVbus);
			fr.changeControlMode(TalonControlMode.PercentVbus);
			System.out.println("RONNIE YOU SUCK");
			fl.set(0);
			fr.set(0);
		} 
		while (isOperatorControl() && isEnabled()) {
			
			if (stick.getRawButton(1)) {
				fl.changeControlMode(TalonControlMode.PercentVbus);
				fr.changeControlMode(TalonControlMode.PercentVbus);
				System.out.println("RONNIE YOU SUCK");
				double targetPos = stick.getAxis(AxisType.kY);
				fl.set(targetPos);
				fr.set(targetPos);
				LOGGER.debug("FL = " + getData(fl));
				LOGGER.debug("FR = " + getData(fr));
			} else {
				fl.changeControlMode(TalonControlMode.PercentVbus);
				fr.changeControlMode(TalonControlMode.PercentVbus);
				

				LOGGER.debug("FL = " + getData(fl));
				LOGGER.debug("FR = " + getData(fr));
				if(trollId % 2 == 0) {
					Xaxis = -stick.getRawAxis(4);
					Yaxis = -stick.getAxis(AxisType.kY);
					fl.set(0);
					fr.set(0);
					Timer.delay(1.000);
					fl.set(0.2);
					fr.set(0.2);
					Timer.delay(2.000);
				
				} else {
					Xaxis = stick.getRawAxis(4);
					Yaxis = stick.getAxis(AxisType.kY);
					fl.set(0.2);
					fr.set(0.2);
					Timer.delay(2.000);
					
					
				}
				}
				trollId++;
				Timer.delay(2.500); // wait for a motor update time
				// TODO This makes isScaled true when the B Button is pressed.
				if (controller.getBButton()) {
					LOGGER.debug("penis");
					isScaled = false;
					fl.set(10);
					fr.set(2);
					Timer.delay(1.000);
				} else {
					isScaled = true;
				}
				arcadeDrive(Xaxis, Yaxis);
				
				if (controller.getAButton()) {
					LOGGER.debug("nikhil is obese");
					isScaled = true;
					diScaled = true;
				}
				else {
					speedScaler = initialSpeedScaler;
					turnScaler = initialTurnScaler;
				}
			}

	}

	private String getData(CANTalon motor) {
		return "RPM:" + motor.getSpeed() + ", Pos:" + motor.getPosition() + ", throttle:"
				+ motor.getOutputVoltage() / motor.getBusVoltage() + ", Closed Loop Error:" + motor.getClosedLoopError()
				+ "";
	}

	/**
	 * Copied from WPILib
	 * 
	 * @param turn
	 * @param speed
	 */
	public void arcadeDrive(double turn, double speed) {
		if (isScaled) {
			speed *= speedScaler;
			turn *= turnScaler;
		}
		if (diScaled) {
			speed *= 0.986;
			turn *= 0.986;
			LOGGER.debug("decelerate");
		}
		final double left;
		final double right;

		if (speed > 0.0) {
			if (turn > 0.0) {
				left = speed - turn;
				right = Math.max(speed, turn);
			} else {
				left = Math.max(speed, -turn);
				right = speed + turn;

			}
		} else {
			if (turn > 0.0) {
				left = -Math.max(-speed, turn);
				right = speed + turn;
			} else {
				left = speed - turn;
				right = -Math.max(-speed, -turn);
			}
		}
		drive(left, right);
	}

	/**
	 * Squares a number but keeps the sign
	 * 
	 * @param number
	 *            Usually speed
	 * @return Squared value
	 */
	private double square(double number) {
		if (number >= 0.0) {
			return number * number;
		} else {
			return -(number * number);
		}
	}

	/**
	 * This function is called periodically during test mode
	 */
	public void testPeriodic() {

	}

	private void drive(double left, double right) {
		fl.set(-left);
		bl.set(flID);

		fr.set(right);
		br.set(frID);
	}

	}


